import "/nmigen/*"
_get_src_loc = import "/nmigen/tracer/get_src_loc"


#: TODO

_SYNTAX_ERROR = src_loc_offset *:text sep:" " ->
    # TODO: use 'src_loc_offset' to remove the shim from the stack trace
    raise SyntaxError $ sep.join text



#: TODO

_current_module = None
_get_module = contruct_name -> _current_module where
    not $ _current_module :: Module =>
        _SYNTAX_ERROR 1 (repr contruct_name) "construction outside of ModuleBuildingContext"
ModuleBuildingContext = (import "/contextlib/contextmanager") $ ->
    pushed_context = _current_module # save reference
    _current_module := Module! # push new
    yield _current_module
    _current_module := pushed_context # pop reference



HIGH = 1
LOW = 0



#: Combinatorics
#:
#: Example:
#:
#:     sync$ drive @a HIGH
#:     comb$ drive @b LOW

drive = signal value -> signal.eq value # todo, find a nice infix way
sync = *:args -> (_get_module 'sync').d.sync += list args
comb = *:args -> (_get_module 'comb').d.comb += list args



#: if, elif, else
#:
#: Example:
#:
#:    If m @op $ ->
#:        m.d.comb += drive @o @sub.o
#:
#:    Elif m @op $ ->
#:        m.d.comb += drive @o @sub.o
#:
#:    Else m $ ->
#:        m.d.comb += drive @o @add.o

If    = cond body_func -> with (_get_module 'If'  ).If   cond => body_func!
Elif  = cond body_func -> with (_get_module 'Elif').Elif cond => body_func!
Else  =      body_func -> with (_get_module 'Else').Else      => body_func!



#: if, elif, else ->
#: when, elsewhen, otherwise
#:
#: Example:
#:
#: when m
#:     @a,->
#:         print 'foo'
#:     @b,->
#:         print 'bar'
#:     otherwise,->
#:         print 'baz'

when = *:pairs ->
    m = _get_module "when"
    is_first = True
    did_else = False
    for (condition, body) in pairs =>
        is_else = condition is otherwise
        if
            did_else =>
                _SYNTAX_ERROR 1 "'otherwise' was not last in 'when' block"

            is_first and not is_else =>
                with m.If condition => # Wanted feature in nMigen: src_loc_at offset
                    body!

            not is_first and not is_else =>
                with m.Elif condition => # Wanted feature in nMigen: src_loc_at offset
                    body!

            is_else =>
                with m.Else! => # Wanted feature in nMigen: src_loc_at offset
                    body!
                did_else = True
        is_first = False


#: todo

switch = value *:pairs ->
    m = _get_module "switch"
    with m.Switch value =>
        for (match, body) in pairs =>
            if
                match is otherwise =>
                    with m.Case! =>
                        body!
                otherwise =>
                    with m.Case match =>
                        body!



#: Construct a nMigen FSM
#:
#: Raises:
#:     SyntaxError: You fucked up
#:
#: :param module: nMigen module
#: :param state: List of functions, where the name of the first positional argument if the name of the state
#:
#: Example:
#:
#:     FSM m
#:         foo1 ->
#:             print "bar1"
#:             foo1.set_next 'foo2'
#:         foo2 ->
#:             print "bar2"
#:             foo2.then.foo3
#:         foo3 ->
#:             print "bar3"
#:             foo3.set_next 'foo1'

FSM = *:states -> fsm where
    m = _get_module "FSM"

    AttrNext = subclass object where
        __getattribute__ = key ~>
            m.next = key

    Next = subclass object where
        __init__ = name ~> None where
            @name = name

        __str__  = self -> @name
        __repr__ = self -> repr @name

        set_next = next_state_name ~>
            m.next = next_state_name


    import '/inspect/signature'
    with fsm = m.FSM! => # TODO: src_loc_at
        for state in states =>
            name = head $ (signature state).parameters.keys!
            with m.State name => # TODO: src_loc_at
                state $ Next name

#: todo

Record = record where
    import '/inspect/signature'
    funcs_to_pairs = funcs ->
        for func in funcs =>
            name = head $ (signature func).parameters.keys!
            yield (name, func None)
    _Record = Record
    record = *:funcs **:kwargs ->
        #kwargs!!"src_loc_at" = 2 + kwargs.get "src_loc_at" 0
        _Record (funcs_to_pairs funcs) **:kwargs



"""
# TODO: eats kwargs
Record = Record <-
    *:funcs ->
        import '/inspect/signature'
        for func in funcs =>
            name = head $ (signature func).parameters.keys!
            yield (name, func None)
"""
