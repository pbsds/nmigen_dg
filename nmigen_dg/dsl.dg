import "/nmigen/*"
_get_src_loc = import "/nmigen/tracer/get_src_loc"


#: TODO

_SYNTAX_ERROR = src_loc_offset *:text sep:" " ->
    # TODO: use 'src_loc_offset' to remove the shim from the stack trace
    raise SyntaxError $ sep.join text



#: TODO

_current_module = None
_get_module = NmigenModule contruct_name -> _current_module where
    not $ _current_module :: NmigenModule =>
        _SYNTAX_ERROR 1 (repr contruct_name) "construction outside of module_building_context"

module_building_context = (import "/contextlib/contextmanager") $ module ->
    pushed_context = _current_module # save reference
    _current_module := module # push new
    yield module
    _current_module := pushed_context # pop reference

# shadow the nMigen Module
_get_module = bind _get_module Module
Module = module_building_context <- Module


HIGH = 1
LOW  = 0



#: Combinatorics
#:
#: Example:
#:
#:     sync$ drive @a HIGH
#:     comb$ drive @b LOW
#:     domain.mydomain$ drive @c 5

drive = signal value -> signal.eq value # TODO: find a nice infix way

domain = d! where d = subclass object where
    __getattribute__ = domain_name ~>
        *:args ->
            m = _get_module $ 'domain.' + domain_name
            domain = getattr m.d domain_name
            domain += list args
sync = domain.sync
comb = domain.comb



#: if, elif, else
#:
#: Example:
#:
#:    If m @op $ ->
#:        m.d.comb += drive @o @sub.o
#:
#:    Elif m @op $ ->
#:        m.d.comb += drive @o @sub.o
#:
#:    Else m $ ->
#:        m.d.comb += drive @o @add.o

If    = cond body_func -> with (_get_module 'If'  ).If   cond => body_func!
Elif  = cond body_func -> with (_get_module 'Elif').Elif cond => body_func!
Else  =      body_func -> with (_get_module 'Else').Else      => body_func!



#: if, elif, else ->
#: when, elsewhen, otherwise
#:
#: Example:
#:
#: when m
#:     @a,->
#:         print 'foo'
#:     @b,->
#:         print 'bar'
#:     otherwise,->
#:         print 'baz'

when = *:pairs -> None where
    m = _get_module "when"
    if not $ any $ map (::tuple) pairs =>
        if len pairs == 2 and (pairs!!1)::(type (->1)) =>
            condition, body = pairs
            with m.If condition => body!
            return None

    is_first = True
    did_else = False
    for (condition, body) in pairs =>
        is_else = condition is otherwise
        if
            did_else =>
                _SYNTAX_ERROR 1 "'otherwise' was not last in 'when' block"

            is_first and not is_else =>
                with m.If condition => # Wanted feature in nMigen: src_loc_at offset
                    body!

            not is_first and not is_else =>
                with m.Elif condition => # Wanted feature in nMigen: src_loc_at offset
                    body!

            is_else =>
                with m.Else! => # Wanted feature in nMigen: src_loc_at offset
                    body!
                did_else = True
        is_first = False


#: todo

switch = value *:pairs ->
    m = _get_module "switch"
    with m.Switch value =>
        for (match, body) in pairs =>
            if
                match is otherwise =>
                    with m.Case! =>
                        body!
                otherwise =>
                    with m.Case match =>
                        body!



#: Construct a nMigen FSM
#:
#: Raises:
#:     SyntaxError: You fucked up
#:
#: :param module: nMigen module
#: :param state: List of functions, where the name of the first positional argument if the name of the state
#:
#: Example:
#:
#:     FSM m
#:         foo1 ->
#:             print "bar1"
#:             foo1.set_next 'foo2'
#:         foo2 ->
#:             print "bar2"
#:             foo2.then.foo3
#:         foo3 ->
#:             print "bar3"
#:             foo3.set_next 'foo1'

FSM = *:states -> fsm where
    m = _get_module "FSM"

    AttrNext = subclass object where
        __getattribute__ = key ~>
            m.next = key

    Next = subclass object where
        __init__ = name ~> None where
            @name = name

        __str__  = self -> @name
        __repr__ = self -> repr @name

        __getattribute__ = next_state_name ~>
            m.next = next_state_name


    import '/inspect/signature'
    with fsm = m.FSM! => # TODO: src_loc_at
        for state in states =>
            name = head $ (signature state).parameters.keys!
            with m.State name => # TODO: src_loc_at
                state $ Next name

#: todo

Record = record where
    import '/inspect/signature'
    funcs_to_pairs = funcs ->
        for func in funcs =>
            name = head $ (signature func).parameters.keys!
            yield (name, func None)
    _Record = Record
    record = *:funcs **:kwargs ->
        #kwargs!!"src_loc_at" = 2 + kwargs.get "src_loc_at" 0
        _Record (funcs_to_pairs funcs) **:kwargs
