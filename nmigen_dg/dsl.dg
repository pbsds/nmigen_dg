import "/nmigen/*"
_get_src_loc = import "/nmigen/tracer/get_src_loc" pure
_contextmanager = import "/contextlib/contextmanager" pure
_signature = import '/inspect/signature' pure

#: TODO

_SYNTAX_ERROR = src_loc_offset *:text sep:" " ->
    # TODO: use 'src_loc_offset' to remove the shim from the stack trace
    raise SyntaxError $ sep.join text



#: TODO

# shadow the Module function with our own: a context manager

_current_module = None # global variable with the currently active Module being elaborated
module_elaboration_context = _contextmanager $ module -> # how we set _current_module
    pushed_context = _current_module # store the current module
    _current_module := module # push new module
    yield module # yield a reference of the module to the caller
    _current_module := pushed_context # pop of the module

_get_module = bind getter Module where # bind a reference to the original nmigen module
    getter = Module debug_name -> _current_module where
        not $ _current_module :: Module =>
            _SYNTAX_ERROR 1 (repr debug_name) "construction used outside of a module_elaboration_context"
Module = (-> context_maker!) where
    context_maker = module_elaboration_context <- Module # bind a reference to the original nmigen module


#: constants

#(TODO: remove?)
HIGH = 1
LOW  = 0


#: 'Drive a b' instead of 'a.eq b' or a |>.eq b

Drive = signal value -> signal.eq value # TODO: find a nice infix way


#: Registering domains
#:
#: Example:
#:
#:     Sync$ Drive @a HIGH
#:     Comb$ Drive @b LOW
#:     Domain.mydomain$ Drive @c 5
#:     Mydomain = Domain.mydomain
#:     Mydomain$ Drive @d 6

Domains = Obj! where Obj = subclass object where
    __getattribute__ = domain_name ~>
        *:statements -> # accepts any amount of statments
            m = _get_module $ 'Domains.' + domain_name
            domain = m.d `getattr` domain_name
            domain += list statements
Sync = Domains.sync
Comb = Domains.comb



#: if, elif, else -> When + otherwise
#:
#: Example:
#:
#: When @x $ ->
#:     print "eyo"
#:
#: When
#:     @a,->
#:         print "foo"
#:     @b,->
#:         print "bar"
#:     otherwise,->
#:         print "baz"

When = *:pairs -> None where
    m = _get_module "When"
    if not $ any $ map (::tuple) pairs =>
        if len pairs == 2 and (pairs!!1)::(type (->1)) =>
            condition, body = pairs
            with m.If condition => body!
            return None

    is_first = True
    did_else = False
    for (condition, body) in pairs =>
        is_else = condition is otherwise
        if
            did_else =>
                _SYNTAX_ERROR 1 "'otherwise' was not last in 'When' block"

            is_first and not is_else =>
                with m.If condition => # Wanted feature in nMigen: src_loc_at offset
                    body!

            not is_first and not is_else =>
                with m.Elif condition => # Wanted feature in nMigen: src_loc_at offset
                    body!

            is_else =>
                with m.Else! => # Wanted feature in nMigen: src_loc_at offset
                    body!
                did_else = True
        is_first = False



#: Switch
#:
#: Example:
#:
#: Switch $input
#:     1 ,->
#:         print "foo"
#:     2 ,->
#:         print "bar"
#:     otherwise ,->
#:         print "baz"

Switch = value *:cases ->
    m = _get_module "Switch"
    with m.Switch value =>
        for (match, body) in cases => if
            match is otherwise =>
                with m.Case! =>
                    body!
            otherwise =>
                with m.Case match =>
                    body!



#: Construct a nMigen FSM
#:
#: Raises:
#:     SyntaxError: You dun goof'd
#:
#: :param states: List of functions, where the name of the first positional argument if the name of the state
#:
#: Example:
#:
#:     FSM
#:         state1 ->
#:             print "bar1"
#:             state1 |>. state2
#:         state2 ->
#:             print "bar2"
#:             state2 |>. state3
#:         state3 ->
#:             print "bar3"
#:             state3 |>. state1

FSM = *:states -> fsm where
    m = _get_module "FSM"

    AttrNext = subclass object where
        __getattribute__ = key ~>
            m.next = key

    Next = subclass object where
        __init__ = name ~> None where
            @name = name

        __str__  = self -> @name
        __repr__ = self -> repr @name

        __getattribute__ = next_state_name ~>
            m.next = next_state_name


    names = list (where for state_body in states =>
        yield head $ (_signature state_body).parameters.keys!)

    with fsm = m.FSM! => # TODO: src_loc_at
        for (name, state_body) in zip names states =>
            with m.State name => # TODO: src_loc_at
                state_body $ Next name


#: todo

Record = record where
    funcs_to_pairs = funcs ->
        for func in funcs =>
            name = head $ (_signature func).parameters.keys!
            yield (name, func None)
    _Record = Record
    record = *:funcs **:kwargs ->
        #kwargs!!"src_loc_at" = 2 + kwargs.get "src_loc_at" 0
        _Record (funcs_to_pairs funcs) **:kwargs
